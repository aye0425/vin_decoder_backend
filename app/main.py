# main.py
import uvicorn
from fastapi import Depends, FastAPI, HTTPException, Request, status
from fastapi.responses import StreamingResponse, JSONResponse
from fastapi.exceptions import RequestValidationError
from fastapi.encoders import jsonable_encoder
from sqlalchemy.orm import Session
import pandas as pd
import io
from . import crud, models, schemas, vPIC_api
from .database import SessionLocal, engine

models.Base.metadata.create_all(bind=engine)

file_name = 'vehicle_cache.parquet'
app = FastAPI(title='VIN Decoder')

# Dependency
def get_db():
  db = SessionLocal()
  try:
    yield db
  finally:
    db.close()

# Handles the ValueError response generated by pydantic validator on VIN input
@app.exception_handler(RequestValidationError)
async def value_error_exception_handler(request: Request, exc: ValueError):
  return JSONResponse(
    status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
    content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
  )

# Check that server is running
@app.get("/")
async def root(db: Session = Depends(get_db)):
  return {"healthCheck": "Server Running"}

# Look up VIN in cache, if not available process from vPIC API and store in cache
@app.post("/lookup", response_model=schemas.Vehicle)
async def fetch_vehicle_data(vehicle: schemas.VehicleBase, db: Session = Depends(get_db)):
  # Find in cache
  db_vehicle = crud.get_vehicle_by_vin(db, vin=vehicle.vin)
  
  # If in cache, check that is_cached is set to False. If False update isCached to True and return result, else return existing record from cache
  if db_vehicle:
    if not db_vehicle.isCached:
      return crud.update_vehicle(db, db_vehicle)
    return db_vehicle
  
  # Process the vehicle data from vPIC and store the resulting data into cache
  new_vehicle = vPIC_api.process_decoded_vin(vehicle.vin, vPIC_api.decode_vin(vehicle.vin))
  return crud.create_vehicle(db=db, vehicle=new_vehicle)

# Delete vehicle record from db
@app.post("/remove")
async def delete_vehicle_data(vehicle: schemas.VehicleBase, db: Session = Depends(get_db)):
  # Find record by VIN
  db_vehicle = crud.get_vehicle_by_vin(db, vin=vehicle.vin)

  # Raise exception if result is not in cache
  if db_vehicle is None:
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="VIN not found")
  
  # Remove record from cache and return VIN deleted and success
  crud.delete_vehicle_by_vin(db, db_vehicle)
  return {"vin": vehicle.vin, "deleteSuccess": True}

# Download cache into a parquet file
@app.get("/export")
async def export_bin_file(db: Session = Depends(get_db)):
  queries = crud.get_all_vehicles(db)
  
  df = pd.DataFrame(jsonable_encoder(queries))

  return StreamingResponse(io.BytesIO(df.to_parquet(file_name)))

# Start Uvicorn programmatically
if __name__ == "__main__":
  uvicorn.run(app, host="127.0.0.1", port=8000, log_level="info")